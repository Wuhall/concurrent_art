# Java 并发编程艺术

## 使用多线程并行执行并不一定会比串行执行更快
由于多线程会额外产生线程创建与上下文切换的开销  
减少上下文切换有下面一些方法：
1. 无锁并发编程，使用分段技术（hash算法取模分段等），不同的线程处理不同段的数据
2. CAS算法，使用Java的Atomic包中的CAS算法
3. 尽量使用较少的线程数量

## volatile与synchronized关键字
volatile修饰成员变量，作用是告知程序任何对该变量的访问均需要从共享内存中获取，而对他的改变必须同步刷新回共享内存，他能保证所有线程对变量访问的可见性
synchronized修饰方法或同步代码块，主要是保证多个线程在同一时刻，只能有一个线程处于方法或同步代码块中，保证线程对变量访问的可见性和排他性

## Lock与synchronized的区别
Lock是一个接口，对于使用synchronized而言，调用lock（获取锁）与unlock（释放锁）方法具有更多的灵活性。  
实现lock接口提供的synchronized关键字不具备的特性主要有三点：
1. 尝试非阻塞的获取锁，当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁
2. 能中断地获取锁，当获取到锁的线程被中断时，中断异常会被抛出，同时锁会被释放
3. 超时获取锁，在指定的截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回

## 使用线程池的原因
线程的创建与消亡均是需要消耗系统资源的，线程池技术有以下三个方面的好处：  
1. 降低资源消耗，通过重复利用已经创建的线程降低线程创建和销毁造成的消耗
2. 提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行
3. 提高线程的客观理性，可以对线程进行统一分配、调优以及监控

## 线程池的实现原理
可以使用ThreadPoolExecutor创建一个线程池
1. 判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务
2. 判断工作队列是否已经满了，如果工作队列没有满，则将新提交的任务存储在这个工作队列里
3. 判断线程是否处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果满了，则交给饱和策略来处理这个任务

## 如何合理配置线程池
1. 针对CPU密集型还是IO密集型的任务。如果是CPU密集型任务，可以配置cpu核心数+1线程的线程池，IO密集型任务的线程不是一直在执行任务，则应配置尽可能多的线程，比如2*cpu核心数
2. 针对任务优先级，可以考虑使用priorityblockingqueue进行处理
3. 依赖数据库连接池的任务，因为线程提交sql后需要等待数据库返回结果，等待时间越长，则CPU空闲的时间越长，那么线程数量应该设置的越大，这样才能更好的利用CPU
4. 使用有界队列，增加预警能力

## juc java.util.concurrent
### 悲观锁与乐观锁
- 悲观锁：认为在线程获得资源时候，会有其他线程来抢占，因此每次获得资源时候，都会加锁。synchronized与lock实现类都是悲观锁。
- 乐观锁：认为在线程获得资源时候，不会有其他线程来抢占，所以不会加锁。通过在获得数据时候，判断之前有没有其他线程更新这个数据。判断规则版本号机制、CAS（比较交换）算法

### 高并发时候对锁的使用要求
高并发时候，同步调用应该尽量去考虑锁的性能损耗。能用无锁的数据结构就用无锁，能锁区块就不要锁整个方法体，能用对象锁，就不要用类锁。
尽可能使加锁的代码块尽可能的小，避免在代码块中调用RPC方法。  
[synchronized使用案例](src/main/java/com/wuhall/juc/lock)
1. 一个对象里面如果有多个synchronized方法，某一个时刻内，只要有一个线程去调用其中的一个synchronized方法，那么其他线程都只能等待，因为他锁的是当前对象this
2. 对于普通同步方法，锁的是当前实例对象，通常是this；对于静态方法，锁的是当前类的Class对象，唯一的class模板；对于同步代码块，锁的是synchronized（）中的内容

[公平锁与非公平锁](src/main/java/com/wuhall/juc/fair)
公平锁根据fifo原则（队列先进先出）
非公平锁不是按照申请锁的顺序，在高并发的场景下，有可能造成优先级翻转或者饥饿的状态，即某个线程一直获取不到资源

### 使用非公平锁的原因是什么，公平锁与非公平锁的使用场景
使用非公平锁是为了减少线程切换的开销，
对于资源访问的顺序没有特殊的要求，例如在大多数情况下，资源的获取都能够快速完成，存在较少线程竞争的情况下，使用非公平锁有利于增加系统的吞吐量
公平锁需要维护等待队列，通常会带来一些额外的性能开销，适用于防止线程过度竞争的场景

### synchronized默认是可重入锁
可重入锁是指在外层使用锁之后，在内存仍然可以被使用
[案例1](src/main/java/com/wuhall/juc/lock/ReEntryLockDemo.java)

[死锁案例](src/main/java/com/wuhall/juc/lock/DeadLockDemo.java)  
- 排查死锁
```aidl
jsp -l  // jvm运行程序
jstack [pid] // jvm运行的堆栈信息
```




