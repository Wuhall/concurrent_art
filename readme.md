# Java 并发编程艺术

## 使用多线程并行执行并不一定会比串行执行更快
由于多线程会额外产生线程创建与上下文切换的开销  
减少上下文切换有下面一些方法：
1. 无锁并发编程，使用分段技术（hash算法取模分段等），不同的线程处理不同段的数据
2. CAS算法，使用Java的Atomic包中的CAS算法
3. 尽量使用较少的线程数量

## volatile与synchronized关键字
volatile修饰成员变量，作用是告知程序任何对该变量的访问均需要从共享内存中获取，而对他的改变必须同步刷新回共享内存，他能保证所有线程对变量访问的可见性
synchronized修饰方法或同步代码块，主要是保证多个线程在同一时刻，只能有一个线程处于方法或同步代码块中，保证线程对变量访问的可见性和排他性

## Lock与synchronized的区别
Lock是一个接口，对于使用synchronized而言，调用lock（获取锁）与unlock（释放锁）方法具有更多的灵活性。  
实现lock接口提供的synchronized关键字不具备的特性主要有三点：
1. 尝试非阻塞的获取锁，当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁
2. 能中断地获取锁，当获取到锁的线程被中断时，中断异常会被抛出，同时锁会被释放
3. 超时获取锁，在指定的截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回

## 使用线程池的原因
线程的创建与消亡均是需要消耗系统资源的，线程池技术有以下三个方面的好处：  
1. 降低资源消耗，通过重复利用已经创建的线程降低线程创建和销毁造成的消耗
2. 提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行
3. 提高线程的客观理性，可以对线程进行统一分配、调优以及监控

## 线程池的实现原理
可以使用ThreadPoolExecutor创建一个线程池
1. 判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务
2. 判断工作队列是否已经满了，如果工作队列没有满，则将新提交的任务存储在这个工作队列里
3. 判断线程是否处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果满了，则交给饱和策略来处理这个任务

## 如何合理配置线程池
1. 针对CPU密集型还是IO密集型的任务。如果是CPU密集型任务，可以配置cpu核心数+1线程的线程池，IO密集型任务的线程不是一直在执行任务，则应配置尽可能多的线程，比如2*cpu核心数
2. 针对任务优先级，可以考虑使用priorityblockingqueue进行处理
3. 依赖数据库连接池的任务，因为线程提交sql后需要等待数据库返回结果，等待时间越长，则CPU空闲的时间越长，那么线程数量应该设置的越大，这样才能更好的利用CPU
4. 使用有界队列，增加预警能力



